using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Microsoft.AspNet.Razor.Generator.Compiler.CSharp
{
    public class CSharpCodeBuilder : CodeBuilder
    {
        public CSharpCodeBuilder(CodeTree codeTree, string rootNamespace, RazorEngineHost host, string sourceFile)
            : base(codeTree)
        {
            Host = host;
            RootNamespace = rootNamespace;
            SourceFile = sourceFile;
        }

        public RazorEngineHost Host { get; private set; }
        public string RootNamespace { get; private set; }
        public string SourceFile { get; private set; }

        public override CodeBuilderResult Build()
        {
            var writer = new CSharpCodeWriter();

            // TODO: Combine into one string (perf)
            writer.WriteComment(new string('-', 78))
                  .WriteComment("<auto-generated>")
                  .WriteComment("    This code was generated by a tool.")
#if NET45
                  .WriteComment("    Runtime Version: " + Assembly.GetExecutingAssembly().ImageRuntimeVersion)
#endif
                  .WriteComment("")
                  .WriteComment("    Changes to this file may cause incorrect behavior and will be lost if")
                  .WriteComment("    the code is regenerated.")
                  .WriteComment("</auto-generated>")
                  .WriteComment(new string('-', 78))
                  .WriteLine();

            using (writer.BuildNamespace(RootNamespace))
            {
                // Write out using directives
                AddImports(Tree, writer, Host.NamespaceImports);

                // TODO: Include current projects namespace?  Does that happen to be included in the namespace imports?

                var baseTypeVisitor = new CSharpBaseTypeVisitor(writer);

                baseTypeVisitor.Accept(Tree.Chunks);

                string baseType = baseTypeVisitor.CurrentBaseType ?? Host.DefaultBaseClass;

                // Separate the usings and the class
                writer.WriteLine();

                new CSharpClassAttributeVisitor(writer).Accept(Tree.Chunks);

                using (writer.BuildClassDeclaration("public", Host.DefaultClassName, String.IsNullOrEmpty(baseType) ? new string[0] : new string[] { baseType }))
                {
                    if (Host.DesignTimeMode)
                    {
                        writer.WriteLine("private static object @__o;");
                    }

                    new CSharpHelperVisitor(writer, Host, SourceFile).Accept(Tree.Chunks);
                    new CSharpTypeMemberVisitor(writer, SourceFile).Accept(Tree.Chunks);
                    new CSharpDesignTimeHelpersVisitor(writer, Host, SourceFile).Accept(Tree);

                    // TODO: resolve variable declarations

                    writer.WriteLineHiddenDirective();
                    using (writer.BuildConstructor(Host.DefaultClassName))
                    {
                        // Any constructor based logic that we need to add?
                    };

                    // Add space inbetween constructor and method body
                    writer.WriteLine();

                    using (writer.BuildMethodDeclaration("public override", "void", Host.GeneratedClassContext.ExecuteMethodName))
                    {
                        new CSharpCodeVisitor(writer, Host, SourceFile).Accept(Tree.Chunks);
                    }
                }
            }

            return new CodeBuilderResult(writer.ToString(), writer.LineMappingManager.Mappings);
        }

        private void AddImports(CodeTree codeTree, CSharpCodeWriter writer, IEnumerable<string> defaultImports)
        {
            // Write out using directives
            var usingVisitor = new CSharpUsingVisitor(writer, SourceFile);
            foreach (Chunk chunk in Tree.Chunks)
            {
                usingVisitor.Accept(chunk);
            }

            defaultImports = defaultImports.Except(usingVisitor.ImportedUsings);

            foreach (string import in defaultImports)
            {
                writer.WriteUsing(import);
            }
        }
    }
}
