
// <auto-generated />

namespace Microsoft.AspNet.Razor
{
    using System.Globalization;
    using System.Reflection;
    using System.Resources;

    internal static class RazorResources
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.AspNet.Razor.RazorResources", typeof(RazorResources).GetTypeInfo().Assembly);

        /// <summary>
		/// The active parser must the same as either the markup or code parser.
        /// </summary>
        internal static string ActiveParser_Must_Be_Code_Or_Markup_Parser
        {
            get { return GetString("ActiveParser_Must_Be_Code_Or_Markup_Parser"); }
        }

        /// <summary>
		/// code
        /// </summary>
        internal static string BlockName_Code
        {
            get { return GetString("BlockName_Code"); }
        }

        /// <summary>
		/// explicit expression
        /// </summary>
        internal static string BlockName_ExplicitExpression
        {
            get { return GetString("BlockName_ExplicitExpression"); }
        }

        /// <summary>
		/// The "CancelBacktrack" method can be called only while in a look-ahead process started with the "BeginLookahead" method.
        /// </summary>
        internal static string CancelBacktrack_Must_Be_Called_Within_Lookahead
        {
            get { return GetString("CancelBacktrack_Must_Be_Called_Within_Lookahead"); }
        }

        /// <summary>
		/// "EndBlock" was called without a matching call to "StartBlock".
        /// </summary>
        internal static string EndBlock_Called_Without_Matching_StartBlock
        {
            get { return GetString("EndBlock_Called_Without_Matching_StartBlock"); }
        }

        /// <summary>
		/// The "@" character must be followed by a ":", "(", or a C# identifier.  If you intended to switch to markup, use an HTML start tag, for example:
		/// 
		/// @if(isLoggedIn) {
		///     &lt;p&gt;Hello, @user!&lt;/p&gt;
		/// }
        /// </summary>
        internal static string ParseError_AtInCode_Must_Be_Followed_By_Colon_Paren_Or_Identifier_Start
        {
            get { return GetString("ParseError_AtInCode_Must_Be_Followed_By_Colon_Paren_Or_Identifier_Start"); }
        }

        /// <summary>
		/// End of file was reached before the end of the block comment.  All comments started with "/*" sequence must be terminated with a matching "*/" sequence.
        /// </summary>
        internal static string ParseError_BlockComment_Not_Terminated
        {
            get { return GetString("ParseError_BlockComment_Not_Terminated"); }
        }

        /// <summary>
		/// An opening "{0}" is missing the corresponding closing "{1}".
        /// </summary>
        internal static string ParseError_Expected_CloseBracket_Before_EOF(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Expected_CloseBracket_Before_EOF"), p0, p1);
        }

        /// <summary>
		/// The {0} block is missing a closing "{1}" character.  Make sure you have a matching "{1}" character for all the "{2}" characters within this block, and that none of the "{1}" characters are being interpreted as markup.
        /// </summary>
        internal static string ParseError_Expected_EndOfBlock_Before_EOF(object p0, object p1, object p2)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Expected_EndOfBlock_Before_EOF"), p0, p1, p2);
        }

        /// <summary>
		/// Expected "{0}".
        /// </summary>
        internal static string ParseError_Expected_X(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Expected_X"), p0);
        }

        /// <summary>
		/// Inline markup blocks (@&lt;p&gt;Content&lt;/p&gt;) cannot be nested.  Only one level of inline markup is allowed.
        /// </summary>
        internal static string ParseError_InlineMarkup_Blocks_Cannot_Be_Nested
        {
            get { return GetString("ParseError_InlineMarkup_Blocks_Cannot_Be_Nested"); }
        }

        /// <summary>
		/// Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like "&lt;br&gt;".  Instead use self-closing tags like "&lt;br/&gt;".
        /// </summary>
        internal static string ParseError_MarkupBlock_Must_Start_With_Tag
        {
            get { return GetString("ParseError_MarkupBlock_Must_Start_With_Tag"); }
        }

        /// <summary>
		/// The "{0}" element was not closed.  All elements must be either self-closing or have a matching end tag.
        /// </summary>
        internal static string ParseError_MissingEndTag(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_MissingEndTag"), p0);
        }

        /// <summary>
		/// Sections cannot be empty.  The "@section" keyword must be followed by a block of markup surrounded by "{}".  For example:
		/// 
		/// @section Sidebar {
		///    &lt;!-- Markup and text goes here --&gt;
		/// }
        /// </summary>
        internal static string ParseError_MissingOpenBraceAfterSection
        {
            get { return GetString("ParseError_MissingOpenBraceAfterSection"); }
        }

        /// <summary>
		/// Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an "@" character in markup.  It is recommended that you put them at the top of the page, as in the following example:
		/// 
		/// @using System.Drawing;
		/// @{
		///     // OK here to use types from System.Drawing in the page.
		/// }
        /// </summary>
        internal static string ParseError_NamespaceImportAndTypeAlias_Cannot_Exist_Within_CodeBlock
        {
            get { return GetString("ParseError_NamespaceImportAndTypeAlias_Cannot_Exist_Within_CodeBlock"); }
        }

        /// <summary>
		/// Expected a "{0}" but found a "{1}".  Block statements must be enclosed in "{{" and "}}".  You cannot use single-statement control-flow statements in CSHTML pages. For example, the following is not allowed:
		/// 
		/// @if(isLoggedIn)
		///     &lt;p&gt;Hello, @user&lt;/p&gt;
		/// 
		/// Instead, wrap the contents of the block in "{{}}":
		/// 
		/// @if(isLoggedIn) {{
		///     &lt;p&gt;Hello, @user&lt;/p&gt;
		/// }}
        /// </summary>
        internal static string ParseError_SingleLine_ControlFlowStatements_Not_Allowed(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_SingleLine_ControlFlowStatements_Not_Allowed"), p0, p1);
        }

        /// <summary>
		/// Encountered end tag "{0}" with no matching start tag.  Are your start/end tags properly balanced?
        /// </summary>
        internal static string ParseError_UnexpectedEndTag(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_UnexpectedEndTag"), p0);
        }

        /// <summary>
		/// Unexpected {0} after section keyword.  Section names must start with an "_" or alphabetic character, and the remaining characters must be either "_" or alphanumeric.
        /// </summary>
        internal static string ParseError_Unexpected_Character_At_Section_Name_Start(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Unexpected_Character_At_Section_Name_Start"), p0);
        }

        /// <summary>
		/// "{0}" is not valid at the start of a code block.  Only identifiers, keywords, comments, "(" and "{{" are valid.
        /// </summary>
        internal static string ParseError_Unexpected_Character_At_Start_Of_CodeBlock_CS(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Unexpected_Character_At_Start_Of_CodeBlock_CS"), p0);
        }

        /// <summary>
		/// End of file or an unexpected character was reached before the "{0}" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing ("&lt;br /&gt;") or have matching end tags ("&lt;p&gt;Hello&lt;/p&gt;").  If you intended to display a "&lt;" character, use the "&lt;" HTML entity.
        /// </summary>
        internal static string ParseError_UnfinishedTag(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_UnfinishedTag"), p0);
        }

        /// <summary>
		/// Unterminated string literal.  Strings that start with a quotation mark (") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@") can span multiple lines.
        /// </summary>
        internal static string ParseError_Unterminated_String_Literal
        {
            get { return GetString("ParseError_Unterminated_String_Literal"); }
        }

        /// <summary>
		/// Unknown option: "{0}".
        /// </summary>
        internal static string ParseError_UnknownOption(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_UnknownOption"), p0);
        }

        /// <summary>
		/// The "{0}" block was not terminated.  All "{0}" statements must be terminated with a matching "{1}".
        /// </summary>
        internal static string ParseError_BlockNotTerminated(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_BlockNotTerminated"), p0, p1);
        }

        /// <summary>
		/// @section Header { ... }
        /// </summary>
        internal static string SectionExample_CS
        {
            get { return GetString("SectionExample_CS"); }
        }

        /// <summary>
		/// "&lt;text&gt;" and "&lt;/text&gt;" tags cannot contain attributes.
        /// </summary>
        internal static string ParseError_TextTagCannotContainAttributes
        {
            get { return GetString("ParseError_TextTagCannotContainAttributes"); }
        }

        /// <summary>
		/// The "Imports" keyword must be followed by a namespace or a type alias on the same line.
        /// </summary>
        internal static string ParseError_NamespaceOrTypeAliasExpected
        {
            get { return GetString("ParseError_NamespaceOrTypeAliasExpected"); }
        }

        /// <summary>
		/// A space or line break was encountered after the "@" character.  Only valid identifiers, keywords, comments, "(" and "{" are valid at the start of a code block and they must occur immediately following "@" with no space in between.
        /// </summary>
        internal static string ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock_CS
        {
            get { return GetString("ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock_CS"); }
        }

        /// <summary>
		/// The 'inherits' keyword must be followed by a type name on the same line.
        /// </summary>
        internal static string ParseError_InheritsKeyword_Must_Be_Followed_By_TypeName
        {
            get { return GetString("ParseError_InheritsKeyword_Must_Be_Followed_By_TypeName"); }
        }

        /// <summary>
		/// Outer tag is missing a name. The first character of a markup block must be an HTML tag with a valid name.
        /// </summary>
        internal static string ParseError_OuterTagMissingName
        {
            get { return GetString("ParseError_OuterTagMissingName"); }
        }

        /// <summary>
		/// End of file was reached before the end of the block comment.  All comments that start with the "@*" sequence must be terminated with a matching "*@" sequence.
        /// </summary>
        internal static string ParseError_RazorComment_Not_Terminated
        {
            get { return GetString("ParseError_RazorComment_Not_Terminated"); }
        }

        /// <summary>
		/// "{0}" character
        /// </summary>
        internal static string ErrorComponent_Character(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ErrorComponent_Character"), p0);
        }

        /// <summary>
		/// end of file
        /// </summary>
        internal static string ErrorComponent_EndOfFile
        {
            get { return GetString("ErrorComponent_EndOfFile"); }
        }

        /// <summary>
		/// space or line break
        /// </summary>
        internal static string ErrorComponent_Whitespace
        {
            get { return GetString("ErrorComponent_Whitespace"); }
        }

        /// <summary>
		/// End-of-file was found after the "@" character.  "@" must be followed by a valid code block.  If you want to output an "@", escape it using the sequence: "@@"
        /// </summary>
        internal static string ParseError_Unexpected_EndOfFile_At_Start_Of_CodeBlock
        {
            get { return GetString("ParseError_Unexpected_EndOfFile_At_Start_Of_CodeBlock"); }
        }

        /// <summary>
		/// The {0} property of the {1} structure cannot be null.
        /// </summary>
        internal static string Structure_Member_CannotBeNull(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Structure_Member_CannotBeNull"), p0, p1);
        }

        /// <summary>
		/// Expected a "{0}" after the helper parameters.
        /// </summary>
        internal static string ParseError_MissingCharAfterHelperParameters(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_MissingCharAfterHelperParameters"), p0);
        }

        /// <summary>
		/// Expected a "{0}" after the helper name.
        /// </summary>
        internal static string ParseError_MissingCharAfterHelperName(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_MissingCharAfterHelperName"), p0);
        }

        /// <summary>
		/// Helper parameter list is missing a closing ")".
        /// </summary>
        internal static string ParseError_UnterminatedHelperParameterList
        {
            get { return GetString("ParseError_UnterminatedHelperParameterList"); }
        }

        /// <summary>
		/// Helper blocks cannot be nested within each other.
        /// </summary>
        internal static string ParseError_Helpers_Cannot_Be_Nested
        {
            get { return GetString("ParseError_Helpers_Cannot_Be_Nested"); }
        }

        /// <summary>
		/// Parser was started with a null Context property.  The Context property must be set BEFORE calling any methods on the parser.
        /// </summary>
        internal static string Parser_Context_Not_Set
        {
            get { return GetString("Parser_Context_Not_Set"); }
        }

        /// <summary>
		/// Unexpected "{0}" keyword after "@" character.  Once inside code, you do not need to prefix constructs like "{0}" with "@".
        /// </summary>
        internal static string ParseError_Unexpected_Keyword_After_At(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Unexpected_Keyword_After_At"), p0);
        }

        /// <summary>
		/// "{0}" is a reserved word and cannot be used in implicit expressions.  An explicit expression ("@()") must be used.
        /// </summary>
        internal static string ParseError_ReservedWord(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_ReservedWord"), p0);
        }

        /// <summary>
		/// Unexpected {0} after helper keyword.  All helpers must have a name which starts with an "_" or alphabetic character. The remaining characters must be either "_" or alphanumeric.
        /// </summary>
        internal static string ParseError_Unexpected_Character_At_Helper_Name_Start(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Unexpected_Character_At_Helper_Name_Start"), p0);
        }

        /// <summary>
		/// Cannot resume this symbol. Only the symbol immediately preceding the current one can be resumed.
        /// </summary>
        internal static string Tokenizer_CannotResumeSymbolUnlessIsPrevious
        {
            get { return GetString("Tokenizer_CannotResumeSymbolUnlessIsPrevious"); }
        }

        /// <summary>
		/// Cannot finish span, there is no current block. Call StartBlock at least once before finishing a span
        /// </summary>
        internal static string ParserContext_NoCurrentBlock
        {
            get { return GetString("ParserContext_NoCurrentBlock"); }
        }

        /// <summary>
		/// Cannot complete the tree, there are still open blocks.
        /// </summary>
        internal static string ParserContext_CannotCompleteTree_OutstandingBlocks
        {
            get { return GetString("ParserContext_CannotCompleteTree_OutstandingBlocks"); }
        }

        /// <summary>
		/// Cannot complete the tree, StartBlock must be called at least once.
        /// </summary>
        internal static string ParserContext_CannotCompleteTree_NoRootBlock
        {
            get { return GetString("ParserContext_CannotCompleteTree_NoRootBlock"); }
        }

        /// <summary>
		/// Cannot complete action, the parser has finished. Only CompleteParse can be called to extract the final parser results after the parser has finished
        /// </summary>
        internal static string ParserContext_ParseComplete
        {
            get { return GetString("ParserContext_ParseComplete"); }
        }

        /// <summary>
		/// Block cannot be built because a Type has not been specified in the BlockBuilder
        /// </summary>
        internal static string Block_Type_Not_Specified
        {
            get { return GetString("Block_Type_Not_Specified"); }
        }

        /// <summary>
		/// &lt;&lt;character literal&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_CharacterLiteral
        {
            get { return GetString("CSharpSymbol_CharacterLiteral"); }
        }

        /// <summary>
		/// &lt;&lt;comment&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_Comment
        {
            get { return GetString("CSharpSymbol_Comment"); }
        }

        /// <summary>
		/// &lt;&lt;identifier&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_Identifier
        {
            get { return GetString("CSharpSymbol_Identifier"); }
        }

        /// <summary>
		/// &lt;&lt;integer literal&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_IntegerLiteral
        {
            get { return GetString("CSharpSymbol_IntegerLiteral"); }
        }

        /// <summary>
		/// &lt;&lt;keyword&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_Keyword
        {
            get { return GetString("CSharpSymbol_Keyword"); }
        }

        /// <summary>
		/// &lt;&lt;newline sequence&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_Newline
        {
            get { return GetString("CSharpSymbol_Newline"); }
        }

        /// <summary>
		/// &lt;&lt;real literal&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_RealLiteral
        {
            get { return GetString("CSharpSymbol_RealLiteral"); }
        }

        /// <summary>
		/// &lt;&lt;string literal&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_StringLiteral
        {
            get { return GetString("CSharpSymbol_StringLiteral"); }
        }

        /// <summary>
		/// &lt;&lt;white space&gt;&gt;
        /// </summary>
        internal static string CSharpSymbol_Whitespace
        {
            get { return GetString("CSharpSymbol_Whitespace"); }
        }

        /// <summary>
		/// &lt;&lt;unknown&gt;&gt;
        /// </summary>
        internal static string Symbol_Unknown
        {
            get { return GetString("Symbol_Unknown"); }
        }

        /// <summary>
		/// In order to put a symbol back, it must have been the symbol which ended at the current position. The specified symbol ends at {0}, but the current position is {1}
        /// </summary>
        internal static string TokenizerView_CannotPutBack(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("TokenizerView_CannotPutBack"), p0, p1);
        }

        /// <summary>
		/// Unexpected "{0}"
        /// </summary>
        internal static string ParseError_Unexpected(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Unexpected"), p0);
        }

        /// <summary>
		/// Unexpected "{" after "@" character. Once inside the body of a code block (@if {}, @{}, etc.) you do not need to use "@{" to switch to code.
        /// </summary>
        internal static string ParseError_Unexpected_Nested_CodeBlock
        {
            get { return GetString("ParseError_Unexpected_Nested_CodeBlock"); }
        }

        /// <summary>
		/// line break
        /// </summary>
        internal static string ErrorComponent_Newline
        {
            get { return GetString("ErrorComponent_Newline"); }
        }

        /// <summary>
		/// &lt;&lt;newline sequence&gt;&gt;
        /// </summary>
        internal static string HtmlSymbol_NewLine
        {
            get { return GetString("HtmlSymbol_NewLine"); }
        }

        /// <summary>
		/// &lt;&lt;razor comment&gt;&gt;
        /// </summary>
        internal static string HtmlSymbol_RazorComment
        {
            get { return GetString("HtmlSymbol_RazorComment"); }
        }

        /// <summary>
		/// &lt;&lt;text&gt;&gt;
        /// </summary>
        internal static string HtmlSymbol_Text
        {
            get { return GetString("HtmlSymbol_Text"); }
        }

        /// <summary>
		/// &lt;&lt;white space&gt;&gt;
        /// </summary>
        internal static string HtmlSymbol_WhiteSpace
        {
            get { return GetString("HtmlSymbol_WhiteSpace"); }
        }

        /// <summary>
		/// The parser provided to the ParserContext was not a Markup Parser.
        /// </summary>
        internal static string ParserIsNotAMarkupParser
        {
            get { return GetString("ParserIsNotAMarkupParser"); }
        }

        /// <summary>
		/// Cannot use built-in RazorComment handler, language characteristics does not define the CommentStart, CommentStar and CommentBody known symbol types or parser does not override TokenizerBackedParser.OutputSpanBeforeRazorComment
        /// </summary>
        internal static string Language_Does_Not_Support_RazorComment
        {
            get { return GetString("Language_Does_Not_Support_RazorComment"); }
        }

        /// <summary>
		/// Missing value for session state directive.
        /// </summary>
        internal static string ParserEror_SessionDirectiveMissingValue
        {
            get { return GetString("ParserEror_SessionDirectiveMissingValue"); }
        }

        /// <summary>
		/// Cannot call CreateCodeWriter, a CodeWriter was not provided to the Create method
        /// </summary>
        internal static string CreateCodeWriter_NoCodeWriter
        {
            get { return GetString("CreateCodeWriter_NoCodeWriter"); }
        }

        /// <summary>
		/// [BG][{0}] Shutdown
        /// </summary>
        internal static string Trace_BackgroundThreadShutdown(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_BackgroundThreadShutdown"), p0);
        }

        /// <summary>
		/// [BG][{0}] Startup
        /// </summary>
        internal static string Trace_BackgroundThreadStart(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_BackgroundThreadStart"), p0);
        }

        /// <summary>
		/// [BG][{0}] {1} changes arrived
        /// </summary>
        internal static string Trace_ChangesArrived(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_ChangesArrived"), p0, p1);
        }

        /// <summary>
		/// [BG][{0}] Discarded {1} changes
        /// </summary>
        internal static string Trace_ChangesDiscarded(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_ChangesDiscarded"), p0, p1);
        }

        /// <summary>
		/// [BG][{0}] Collecting {1} discarded changes
        /// </summary>
        internal static string Trace_CollectedDiscardedChanges(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_CollectedDiscardedChanges"), p0, p1);
        }

        /// <summary>
		/// Disabled
        /// </summary>
        internal static string Trace_Disabled
        {
            get { return GetString("Trace_Disabled"); }
        }

        /// <summary>
		/// [P][{0}] {3} Change in {2} milliseconds: {1}
        /// </summary>
        internal static string Trace_EditorProcessedChange(object p0, object p1, object p2, object p3)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_EditorProcessedChange"), p0, p1, p2, p3);
        }

        /// <summary>
		/// [P][{0}] Received Change: {1}
        /// </summary>
        internal static string Trace_EditorReceivedChange(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_EditorReceivedChange"), p0, p1);
        }

        /// <summary>
		/// Enabled
        /// </summary>
        internal static string Trace_Enabled
        {
            get { return GetString("Trace_Enabled"); }
        }

        /// <summary>
		/// [Razor] {0}
        /// </summary>
        internal static string Trace_Format(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_Format"), p0);
        }

        /// <summary>
		/// [BG][{0}] no changes arrived?
        /// </summary>
        internal static string Trace_NoChangesArrived(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_NoChangesArrived"), p0);
        }

        /// <summary>
		/// [BG][{0}] Parse Complete in {1} milliseconds
        /// </summary>
        internal static string Trace_ParseComplete(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_ParseComplete"), p0, p1);
        }

        /// <summary>
		/// [M][{0}] Queuing Parse for: {1}
        /// </summary>
        internal static string Trace_QueuingParse(object p0, object p1)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_QueuingParse"), p0, p1);
        }

        /// <summary>
		/// [Razor] Editor Tracing {0}
        /// </summary>
        internal static string Trace_Startup(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_Startup"), p0);
        }

        /// <summary>
		/// [BG][{0}] Trees Compared in {1} milliseconds. Different = {2}
        /// </summary>
        internal static string Trace_TreesCompared(object p0, object p1, object p2)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("Trace_TreesCompared"), p0, p1, p2);
        }

        /// <summary>
		/// Section blocks ("{0}") cannot be nested.  Only one level of section blocks are allowed.
        /// </summary>
        internal static string ParseError_Sections_Cannot_Be_Nested(object p0)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ParseError_Sections_Cannot_Be_Nested"), p0);
        }

        private static string GetString(string name)
        {
            string value = _resourceManager.GetString(name);
            System.Diagnostics.Debug.Assert(value != null);
            return value;
        }
    }
}
