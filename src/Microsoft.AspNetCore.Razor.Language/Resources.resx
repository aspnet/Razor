<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddTagHelperDirective_Description" xml:space="preserve">
    <value>Register Tag Helpers for use in the current document.</value>
  </data>
  <data name="AddTagHelperDirective_StringToken_Description" xml:space="preserve">
    <value>Add tag helpers from the specified type name and assembly name. Specify '*' for the type name to include all tag helper types from the specified assembly.</value>
  </data>
  <data name="AddTagHelperDirective_StringToken_Name" xml:space="preserve">
    <value>TypeName, AssemblyName</value>
  </data>
  <data name="ArgumentCannotBeNullOrEmpty" xml:space="preserve">
    <value>Value cannot be null or an empty string.</value>
  </data>
  <data name="Block_Type_Not_Specified" xml:space="preserve">
    <value>Block cannot be built because a Type has not been specified in the BlockBuilder</value>
  </data>
  <data name="BlockDirectiveCannotBeImported" xml:space="preserve">
    <value>Block directive '{0}' cannot be imported.</value>
  </data>
  <data name="BlockName_Code" xml:space="preserve">
    <value>code</value>
    <comment>This is a literal used when composing ParserError_* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.</comment>
  </data>
  <data name="BlockName_ExplicitExpression" xml:space="preserve">
    <value>explicit expression</value>
    <comment>This is a literal used when composing ParserError_* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.</comment>
  </data>
  <data name="CodeWriter_InvalidNewLine" xml:space="preserve">
    <value>Invalid newline sequence '{0}'. Support newline sequences are '\r\n' and '\n'.</value>
  </data>
  <data name="CSharpSymbol_CharacterLiteral" xml:space="preserve">
    <value>&lt;&lt;character literal&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_Comment" xml:space="preserve">
    <value>&lt;&lt;comment&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_Identifier" xml:space="preserve">
    <value>&lt;&lt;identifier&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_IntegerLiteral" xml:space="preserve">
    <value>&lt;&lt;integer literal&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_Keyword" xml:space="preserve">
    <value>&lt;&lt;keyword&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_Newline" xml:space="preserve">
    <value>&lt;&lt;newline sequence&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_RealLiteral" xml:space="preserve">
    <value>&lt;&lt;real literal&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_StringLiteral" xml:space="preserve">
    <value>&lt;&lt;string literal&gt;&gt;</value>
  </data>
  <data name="CSharpSymbol_Whitespace" xml:space="preserve">
    <value>&lt;&lt;white space&gt;&gt;</value>
  </data>
  <data name="Diagnostic_CodeTarget_UnsupportedExtension" xml:space="preserve">
    <value>The document type '{0}' does not support the extension '{1}'.</value>
  </data>
  <data name="DirectiveDescriptor_InvalidDirectiveKeyword" xml:space="preserve">
    <value>Invalid directive keyword '{0}'. Directives must have a non-empty keyword that consists only of letters.</value>
  </data>
  <data name="DirectiveDescriptor_InvalidNonOptionalToken" xml:space="preserve">
    <value>A non-optional directive token cannot follow an optional directive token.</value>
  </data>
  <data name="DirectiveExpectsIdentifier" xml:space="preserve">
    <value>The '{0}' directive expects an identifier.</value>
  </data>
  <data name="DirectiveExpectsNamespace" xml:space="preserve">
    <value>The '{0}' directive expects a namespace name.</value>
  </data>
  <data name="DirectiveExpectsQuotedStringLiteral" xml:space="preserve">
    <value>The '{0}' directive expects a string surrounded by double quotes.</value>
  </data>
  <data name="DirectiveExpectsTypeName" xml:space="preserve">
    <value>The '{0}' directive expects a type name.</value>
  </data>
  <data name="DirectiveMustAppearAtStartOfLine" xml:space="preserve">
    <value>The '{0}` directive must appear at the start of the line.</value>
  </data>
  <data name="DirectiveTokensMustBeSeparatedByWhitespace" xml:space="preserve">
    <value>The '{0}' directives value(s) must be separated by whitespace.</value>
  </data>
  <data name="DocumentMissingTarget" xml:space="preserve">
    <value>The document of kind '{0}' does not have a '{1}'. The document classifier must set a value for '{2}'.</value>
  </data>
  <data name="DuplicateDirective" xml:space="preserve">
    <value>The '{0}' directive may only occur once per document.</value>
  </data>
  <data name="EndBlock_Called_Without_Matching_StartBlock" xml:space="preserve">
    <value>"EndBlock" was called without a matching call to "StartBlock".</value>
  </data>
  <data name="ErrorComponent_Newline" xml:space="preserve">
    <value>line break</value>
  </data>
  <data name="FeatureDependencyMissing" xml:space="preserve">
    <value>The '{0}' feature requires a '{1}' provided by the '{2}'.</value>
  </data>
  <data name="FeatureMustBeInitialized" xml:space="preserve">
    <value>The feature must be initialized by setting the '{0}' property.</value>
  </data>
  <data name="FunctionsDirective_Description" xml:space="preserve">
    <value>Specify a C# code block.</value>
  </data>
  <data name="HtmlSymbol_NewLine" xml:space="preserve">
    <value>&lt;&lt;newline sequence&gt;&gt;</value>
  </data>
  <data name="HtmlSymbol_RazorComment" xml:space="preserve">
    <value>&lt;&lt;razor comment&gt;&gt;</value>
  </data>
  <data name="HtmlSymbol_Text" xml:space="preserve">
    <value>&lt;&lt;text&gt;&gt;</value>
  </data>
  <data name="HtmlSymbol_WhiteSpace" xml:space="preserve">
    <value>&lt;&lt;white space&gt;&gt;</value>
  </data>
  <data name="InheritsDirective_Description" xml:space="preserve">
    <value>Specify the base class for the current document.</value>
  </data>
  <data name="InheritsDirective_TypeToken_Description" xml:space="preserve">
    <value>The base type that the current page inherits.</value>
  </data>
  <data name="InheritsDirective_TypeToken_Name" xml:space="preserve">
    <value>TypeName</value>
  </data>
  <data name="IntermediateNodeBuilder_PopInvalid" xml:space="preserve">
    <value>The '{0}' operation is not valid when the builder is empty.</value>
  </data>
  <data name="IntermediateNodeReference_CollectionIsReadOnly" xml:space="preserve">
    <value>The node '{0}' has a read-only child collection and cannot be modified.</value>
  </data>
  <data name="IntermediateNodeReference_NodeNotFound" xml:space="preserve">
    <value>The reference is invalid. The node '{0}' could not be found as a child of '{1}'.</value>
  </data>
  <data name="IntermediateNodeReference_NotInitialized" xml:space="preserve">
    <value>The reference is invalid. References initialized with the default constructor cannot modify nodes.</value>
  </data>
  <data name="IntermediateNodes_InvalidParentNode" xml:space="preserve">
    <value>The '{0}' node type can only be used as a direct child of a '{1}' node.</value>
  </data>
  <data name="InvalidOperation_SpanIsNotChangeOwner" xml:space="preserve">
    <value>The node '{0}' is not the owner of change '{1}'.</value>
  </data>
  <data name="InvalidTagHelperLookupText" xml:space="preserve">
    <value>Invalid tag helper directive look up text '{0}'. The correct look up text format is: "name, assemblyName".</value>
  </data>
  <data name="InvalidTagHelperPrefixValue" xml:space="preserve">
    <value>Invalid tag helper directive '{0}' value. '{1}' is not allowed in prefix '{2}'.</value>
  </data>
  <data name="KeyMustNotBeNull" xml:space="preserve">
    <value>The key must not be null.</value>
  </data>
  <data name="Language_Does_Not_Support_RazorComment" xml:space="preserve">
    <value>Cannot use built-in RazorComment handler, language characteristics does not define the CommentStart, CommentStar and CommentBody known symbol types or parser does not override TokenizerBackedParser.OutputSpanBeforeRazorComment</value>
  </data>
  <data name="MismatchedContentEncoding" xml:space="preserve">
    <value>The specified encoding '{0}' does not match the content's encoding '{1}'.</value>
  </data>
  <data name="ParseError_AtInCode_Must_Be_Followed_By_Colon_Paren_Or_Identifier_Start" xml:space="preserve">
    <value>The "@" character must be followed by a ":", "(", or a C# identifier.  If you intended to switch to markup, use an HTML start tag, for example:

@if(isLoggedIn) {{
    &lt;p&gt;Hello, @user!&lt;/p&gt;
}}</value>
    <comment>"{{" is an escape sequence for string.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_BlockComment_Not_Terminated" xml:space="preserve">
    <value>End of file was reached before the end of the block comment.  All comments started with "/*" sequence must be terminated with a matching "*/" sequence.</value>
  </data>
  <data name="ParseError_DirectiveMustHaveValue" xml:space="preserve">
    <value>Directive '{0}' must have a value.</value>
  </data>
  <data name="ParseError_Expected_CloseBracket_Before_EOF" xml:space="preserve">
    <value>An opening "{0}" is missing the corresponding closing "{1}".</value>
  </data>
  <data name="ParseError_Expected_EndOfBlock_Before_EOF" xml:space="preserve">
    <value>The {0} block is missing a closing "{1}" character.  Make sure you have a matching "{1}" character for all the "{2}" characters within this block, and that none of the "{1}" characters are being interpreted as markup.</value>
  </data>
  <data name="ParseError_HelperDirectiveNotAvailable" xml:space="preserve">
    <value>The {0} directive is not supported.</value>
  </data>
  <data name="ParseError_IncompleteQuotesAroundDirective" xml:space="preserve">
    <value>Optional quote around the directive '{0}' is missing the corresponding opening or closing quote.</value>
  </data>
  <data name="ParseError_InlineMarkup_Blocks_Cannot_Be_Nested" xml:space="preserve">
    <value>Inline markup blocks (@&lt;p&gt;Content&lt;/p&gt;) cannot be nested.  Only one level of inline markup is allowed.</value>
  </data>
  <data name="ParseError_MarkupBlock_Must_Start_With_Tag" xml:space="preserve">
    <value>Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like "&lt;br&gt;".  Instead use self-closing tags like "&lt;br/&gt;".</value>
  </data>
  <data name="ParseError_MissingEndTag" xml:space="preserve">
    <value>The "{0}" element was not closed.  All elements must be either self-closing or have a matching end tag.</value>
  </data>
  <data name="ParseError_NamespaceImportAndTypeAlias_Cannot_Exist_Within_CodeBlock" xml:space="preserve">
    <value>Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an "@" character in markup.  It is recommended that you put them at the top of the page, as in the following example:

@using System.Drawing;
@{{
    // OK here to use types from System.Drawing in the page.
}}</value>
    <comment>"{{" is an escape sequence for string.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_OuterTagMissingName" xml:space="preserve">
    <value>Outer tag is missing a name. The first character of a markup block must be an HTML tag with a valid name.</value>
  </data>
  <data name="ParseError_RazorComment_Not_Terminated" xml:space="preserve">
    <value>End of file was reached before the end of the block comment.  All comments that start with the "@*" sequence must be terminated with a matching "*@" sequence.</value>
  </data>
  <data name="ParseError_ReservedWord" xml:space="preserve">
    <value>"{0}" is a reserved word and cannot be used in implicit expressions.  An explicit expression ("@()") must be used.</value>
  </data>
  <data name="ParseError_Sections_Cannot_Be_Nested" xml:space="preserve">
    <value>Section blocks ("{0}") cannot be nested.  Only one level of section blocks are allowed.</value>
  </data>
  <data name="ParseError_SingleLine_ControlFlowStatements_Not_Allowed" xml:space="preserve">
    <value>Expected a "{0}" but found a "{1}".  Block statements must be enclosed in "{{" and "}}".  You cannot use single-statement control-flow statements in CSHTML pages. For example, the following is not allowed:

@if(isLoggedIn)
    &lt;p&gt;Hello, @user&lt;/p&gt;

Instead, wrap the contents of the block in "{{}}":

@if(isLoggedIn) {{
    &lt;p&gt;Hello, @user&lt;/p&gt;
}}</value>
    <comment>{0} is only ever a single character</comment>
  </data>
  <data name="ParseError_TextTagCannotContainAttributes" xml:space="preserve">
    <value>"&lt;text&gt;" and "&lt;/text&gt;" tags cannot contain attributes.</value>
  </data>
  <data name="ParseError_Unexpected_Character_At_Start_Of_CodeBlock" xml:space="preserve">
    <value>"{0}" is not valid at the start of a code block.  Only identifiers, keywords, comments, "(" and "{{" are valid.</value>
    <comment>"{{" is an escape sequence for string.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_Unexpected_EndOfFile_At_Start_Of_CodeBlock" xml:space="preserve">
    <value>End-of-file was found after the "@" character.  "@" must be followed by a valid code block.  If you want to output an "@", escape it using the sequence: "@@"</value>
  </data>
  <data name="ParseError_Unexpected_Nested_CodeBlock" xml:space="preserve">
    <value>Unexpected "{{" after "@" character. Once inside the body of a code block (@if {{}}, @{{}}, etc.) you do not need to use "@{{" to switch to code.</value>
    <comment>"{{" is an escape sequence for string.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock" xml:space="preserve">
    <value>A space or line break was encountered after the "@" character.  Only valid identifiers, keywords, comments, "(" and "{{" are valid at the start of a code block and they must occur immediately following "@" with no space in between.</value>
    <comment>"{{" is an escape sequence for string.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_UnexpectedEndTag" xml:space="preserve">
    <value>Encountered end tag "{0}" with no matching start tag.  Are your start/end tags properly balanced?</value>
  </data>
  <data name="ParseError_UnfinishedTag" xml:space="preserve">
    <value>End of file or an unexpected character was reached before the "{0}" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing ("&lt;br /&gt;") or have matching end tags ("&lt;p&gt;Hello&lt;/p&gt;").  If you intended to display a "&lt;" character, use the "&amp;lt;" HTML entity.</value>
  </data>
  <data name="ParseError_Unterminated_String_Literal" xml:space="preserve">
    <value>Unterminated string literal.  Strings that start with a quotation mark (") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@") can span multiple lines.</value>
  </data>
  <data name="Parser_Context_Not_Set" xml:space="preserve">
    <value>Parser was started with a null Context property.  The Context property must be set BEFORE calling any methods on the parser.</value>
  </data>
  <data name="ParserContext_CannotCompleteTree_NoRootBlock" xml:space="preserve">
    <value>Cannot complete the tree, StartBlock must be called at least once.</value>
  </data>
  <data name="ParserContext_CannotCompleteTree_OutstandingBlocks" xml:space="preserve">
    <value>Cannot complete the tree, there are still open blocks.</value>
  </data>
  <data name="ParserContext_NoCurrentBlock" xml:space="preserve">
    <value>Cannot finish span, there is no current block. Call StartBlock at least once before finishing a span</value>
  </data>
  <data name="PhaseDependencyMissing" xml:space="preserve">
    <value>The '{0}' phase requires a '{1}' provided by the '{2}'.</value>
  </data>
  <data name="PhaseMustBeInitialized" xml:space="preserve">
    <value>The phase must be initialized by setting the '{0}' property.</value>
  </data>
  <data name="RazorProject_PathMustStartWithForwardSlash" xml:space="preserve">
    <value>Path must begin with a forward slash '/'.</value>
  </data>
  <data name="RazorTemplateEngine_ItemCouldNotBeFound" xml:space="preserve">
    <value>The item '{0}' could not be found.</value>
  </data>
  <data name="RemoveTagHelperDirective_Description" xml:space="preserve">
    <value>Remove Tag Helpers for use in the current document.</value>
  </data>
  <data name="RemoveTagHelperDirective_StringToken_Description" xml:space="preserve">
    <value>Remove tag helpers from the specified type name and assembly name. Specify '*' for the type name to remove all tag helper types from the specified assembly.</value>
  </data>
  <data name="RemoveTagHelperDirective_StringToken_Name" xml:space="preserve">
    <value>TypeName, AssemblyName</value>
  </data>
  <data name="RenderingContextRequiresDelegate" xml:space="preserve">
    <value>The '{0}' requires a '{1}' delegate to be set.</value>
  </data>
  <data name="RewriterError_EmptyTagHelperBoundAttribute" xml:space="preserve">
    <value>Attribute '{0}' on tag helper element '{1}' requires a value. Tag helper bound attributes of type '{2}' cannot be empty or contain only whitespace.</value>
  </data>
  <data name="SectionDirective_Description" xml:space="preserve">
    <value>Define a section to be rendered in the configured layout page.</value>
  </data>
  <data name="SectionDirective_NameToken_Description" xml:space="preserve">
    <value>The name of the section.</value>
  </data>
  <data name="SectionDirective_NameToken_Name" xml:space="preserve">
    <value>SectionName</value>
  </data>
  <data name="SectionExample" xml:space="preserve">
    <value>@section Header { ... }</value>
    <comment>In CSHTML, the @section keyword is case-sensitive and lowercase (as with all C# keywords)</comment>
  </data>
  <data name="Symbol_Unknown" xml:space="preserve">
    <value>&lt;&lt;unknown&gt;&gt;</value>
  </data>
  <data name="TagHelper_InvalidBoundAttributeName" xml:space="preserve">
    <value>Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with name '{2}' because the name contains a '{3}' character.</value>
  </data>
  <data name="TagHelper_InvalidBoundAttributeNameStartsWith" xml:space="preserve">
    <value>Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with name '{2}' because the name starts with '{3}'.</value>
  </data>
  <data name="TagHelper_InvalidBoundAttributeNullOrWhitespace" xml:space="preserve">
    <value>Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with a null or empty name.</value>
  </data>
  <data name="TagHelper_InvalidBoundAttributePrefix" xml:space="preserve">
    <value>Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with prefix '{2}' because the prefix contains a '{3}' character.</value>
  </data>
  <data name="TagHelper_InvalidBoundAttributePrefixStartsWith" xml:space="preserve">
    <value>Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with prefix '{2}' because the prefix starts with '{3}'.</value>
  </data>
  <data name="TagHelper_InvalidRestrictedChild" xml:space="preserve">
    <value>Invalid restricted child '{1}' for tag helper '{0}'. Tag helpers cannot restrict child elements that contain a '{2}' character.</value>
  </data>
  <data name="TagHelper_InvalidRestrictedChildNullOrWhitespace" xml:space="preserve">
    <value>Invalid restricted child for tag helper '{0}'. Name cannot be null or whitespace.</value>
  </data>
  <data name="TagHelper_InvalidTargetedAttributeName" xml:space="preserve">
    <value>Tag helpers cannot target attribute name '{0}' because it contains a '{1}' character.</value>
  </data>
  <data name="TagHelper_InvalidTargetedAttributeNameNullOrWhitespace" xml:space="preserve">
    <value>Targeted attribute name cannot be null or whitespace.</value>
  </data>
  <data name="TagHelper_InvalidTargetedParentTagName" xml:space="preserve">
    <value>Tag helpers cannot target parent tag name '{0}' because it contains a '{1}' character.</value>
  </data>
  <data name="TagHelper_InvalidTargetedParentTagNameNullOrWhitespace" xml:space="preserve">
    <value>Targeted parent tag name cannot be null or whitespace.</value>
  </data>
  <data name="TagHelper_InvalidTargetedTagName" xml:space="preserve">
    <value>Tag helpers cannot target tag name '{0}' because it contains a '{1}' character.</value>
  </data>
  <data name="TagHelper_InvalidTargetedTagNameNullOrWhitespace" xml:space="preserve">
    <value>Targeted tag name cannot be null or whitespace.</value>
  </data>
  <data name="TagHelperAssemblyNameCannotBeEmptyOrNull" xml:space="preserve">
    <value>Tag helper directive assembly name cannot be null or empty.</value>
  </data>
  <data name="TagHelperBlockRewriter_IndexerAttributeNameMustIncludeKey" xml:space="preserve">
    <value>The tag helper attribute '{0}' in element '{1}' is missing a key. The syntax is '&lt;{1} {0}{{ key }}="value"&gt;'.</value>
  </data>
  <data name="TagHelperBlockRewriter_TagHelperAttributeListMustBeWellFormed" xml:space="preserve">
    <value>TagHelper attributes must be well-formed.</value>
  </data>
  <data name="TagHelperParseTreeRewriter_CannotHaveNonTagContent" xml:space="preserve">
    <value>The parent &lt;{0}&gt; tag helper does not allow non-tag content. Only child tag helper(s) targeting tag name(s) '{1}' are allowed.</value>
  </data>
  <data name="TagHelperParseTreeRewriter_EndTagTagHelperMustNotHaveAnEndTag" xml:space="preserve">
    <value>Found an end tag (&lt;/{0}&gt;) for tag helper '{1}' with tag structure that disallows an end tag ('{2}').</value>
  </data>
  <data name="TagHelperParseTreeRewriter_InconsistentTagStructure" xml:space="preserve">
    <value>Tag helpers '{0}' and '{1}' targeting element '{2}' must not expect different {3} values.</value>
  </data>
  <data name="TagHelperParseTreeRewriter_InvalidNestedTag" xml:space="preserve">
    <value>The &lt;{0}&gt; tag is not allowed by parent &lt;{1}&gt; tag helper. Only child tags with name(s) '{2}' are allowed.</value>
  </data>
  <data name="TagHelperPrefixDirective_Description" xml:space="preserve">
    <value>Specify a prefix that is required in an element name for it to be included in Tag Helper processing.</value>
  </data>
  <data name="TagHelperPrefixDirective_PrefixToken_Description" xml:space="preserve">
    <value>The tag prefix to apply to tag helpers.</value>
  </data>
  <data name="TagHelperPrefixDirective_PrefixToken_Name" xml:space="preserve">
    <value>Prefix</value>
  </data>
  <data name="TagHelpers_AttributesMustHaveAName" xml:space="preserve">
    <value>Tag Helper '{0}'s attributes must have names.</value>
  </data>
  <data name="TagHelpers_CannotHaveCSharpInTagDeclaration" xml:space="preserve">
    <value>The tag helper '{0}' must not have C# in the element's attribute declaration area.</value>
  </data>
  <data name="TagHelpers_CodeBlocks_NotSupported_InAttributes" xml:space="preserve">
    <value>Code blocks (e.g. @{{var variable = 23;}}) must not appear in non-string tag helper attribute values.
 Already in an expression (code) context. If necessary an explicit expression (e.g. @(@readonly)) may be used.</value>
  </data>
  <data name="TagHelpers_InlineMarkupBlocks_NotSupported_InAttributes" xml:space="preserve">
    <value>Inline markup blocks (e.g. @&lt;p&gt;content&lt;/p&gt;) must not appear in non-string tag helper attribute values.
 Expected a '{0}' attribute value, not a string.</value>
  </data>
  <data name="TagHelpersParseTreeRewriter_FoundMalformedTagHelper" xml:space="preserve">
    <value>Found a malformed '{0}' tag helper. Tag helpers must have a start and end tag or be self closing.</value>
  </data>
  <data name="TagHelpersParseTreeRewriter_MissingCloseAngle" xml:space="preserve">
    <value>Missing close angle for tag helper '{0}'.</value>
  </data>
  <data name="UnexpectedDirectiveKind" xml:space="preserve">
    <value>Unreachable code. This can happen when a new {0} is introduced.</value>
  </data>
  <data name="UnexpectedDirectiveLiteral" xml:space="preserve">
    <value>Unexpected literal following the '{0}' directive. Expected '{1}'.</value>
  </data>
  <data name="UnexpectedEOFAfterDirective" xml:space="preserve">
    <value>Unexpected end of file following the '{0}' directive. Expected '{1}'.</value>
  </data>
  <data name="UnsupportedChecksumAlgorithm" xml:space="preserve">
    <value>The hash algorithm '{0}' is not supported for checksum generation. Supported algorithms are: '{1}'. Set '{2}' to '{3}' to suppress automatic checksum generation.</value>
  </data>
  <data name="PropertyMustNotBeNull" xml:space="preserve">
    <value>The '{0}.{1}' property must not be null.</value>
  </data>
  <data name="RazorProjectEngineMissingFeatureDependency" xml:space="preserve">
    <value>The '{0}' is missing feature '{1}'.</value>
  </data>
  <data name="RazorLanguageVersion_InvalidVersion" xml:space="preserve">
    <value>The Razor language version '{0}' is unrecognized or not supported by this version of Razor.</value>
  </data>
  <data name="VirtualFileSystem_FileDoesNotBelongToDirectory" xml:space="preserve">
    <value>File path '{0}' does not belong to the directory '{1}'.</value>
  </data>
  <data name="VirtualFileSystem_InvalidRelativePath" xml:space="preserve">
    <value>The file path '{0}' is invalid. File path is the root relative path of the file starting with '/' and should not contain any '\' characters.</value>
  </data>
</root>