// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax
{
  internal abstract partial class RazorSyntaxNode : GreenNode
  {
    internal RazorSyntaxNode(SyntaxKind kind, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal RazorSyntaxNode(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  internal sealed partial class RazorCommentBlockSyntax : RazorSyntaxNode
  {
    private readonly SyntaxToken _startCommentTransition;
    private readonly SyntaxToken _startCommentStar;
    private readonly SyntaxToken _comment;
    private readonly SyntaxToken _endCommentStar;
    private readonly SyntaxToken _endCommentTransition;

    internal RazorCommentBlockSyntax(SyntaxKind kind, SyntaxToken startCommentTransition, SyntaxToken startCommentStar, SyntaxToken comment, SyntaxToken endCommentStar, SyntaxToken endCommentTransition, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 5;
        AdjustFlagsAndWidth(startCommentTransition);
        _startCommentTransition = startCommentTransition;
        AdjustFlagsAndWidth(startCommentStar);
        _startCommentStar = startCommentStar;
        if (comment != null)
        {
            AdjustFlagsAndWidth(comment);
            _comment = comment;
        }
        AdjustFlagsAndWidth(endCommentStar);
        _endCommentStar = endCommentStar;
        AdjustFlagsAndWidth(endCommentTransition);
        _endCommentTransition = endCommentTransition;
    }


    internal RazorCommentBlockSyntax(SyntaxKind kind, SyntaxToken startCommentTransition, SyntaxToken startCommentStar, SyntaxToken comment, SyntaxToken endCommentStar, SyntaxToken endCommentTransition)
        : base(kind)
    {
        SlotCount = 5;
        AdjustFlagsAndWidth(startCommentTransition);
        _startCommentTransition = startCommentTransition;
        AdjustFlagsAndWidth(startCommentStar);
        _startCommentStar = startCommentStar;
        if (comment != null)
        {
            AdjustFlagsAndWidth(comment);
            _comment = comment;
        }
        AdjustFlagsAndWidth(endCommentStar);
        _endCommentStar = endCommentStar;
        AdjustFlagsAndWidth(endCommentTransition);
        _endCommentTransition = endCommentTransition;
    }

    public SyntaxToken StartCommentTransition { get { return _startCommentTransition; } }
    public SyntaxToken StartCommentStar { get { return _startCommentStar; } }
    public SyntaxToken Comment { get { return _comment; } }
    public SyntaxToken EndCommentStar { get { return _endCommentStar; } }
    public SyntaxToken EndCommentTransition { get { return _endCommentTransition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _startCommentTransition;
            case 1: return _startCommentStar;
            case 2: return _comment;
            case 3: return _endCommentStar;
            case 4: return _endCommentTransition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.RazorCommentBlockSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRazorCommentBlock(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRazorCommentBlock(this);
    }

    public RazorCommentBlockSyntax Update(SyntaxToken startCommentTransition, SyntaxToken startCommentStar, SyntaxToken comment, SyntaxToken endCommentStar, SyntaxToken endCommentTransition)
    {
        if (startCommentTransition != StartCommentTransition || startCommentStar != StartCommentStar || comment != Comment || endCommentStar != EndCommentStar || endCommentTransition != EndCommentTransition)
        {
            var newNode = SyntaxFactory.RazorCommentBlock(startCommentTransition, startCommentStar, comment, endCommentStar, endCommentTransition);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new RazorCommentBlockSyntax(Kind, _startCommentTransition, _startCommentStar, _comment, _endCommentStar, _endCommentTransition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RazorCommentBlockSyntax(Kind, _startCommentTransition, _startCommentStar, _comment, _endCommentStar, _endCommentTransition, GetDiagnostics(), annotations);
    }
  }

  internal abstract partial class HtmlSyntaxNode : RazorSyntaxNode
  {
    internal HtmlSyntaxNode(SyntaxKind kind, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal HtmlSyntaxNode(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  internal sealed partial class HtmlTextLiteralSyntax : HtmlSyntaxNode
  {
    private readonly GreenNode _textTokens;

    internal HtmlTextLiteralSyntax(SyntaxKind kind, GreenNode textTokens, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 1;
        if (textTokens != null)
        {
            AdjustFlagsAndWidth(textTokens);
            _textTokens = textTokens;
        }
    }


    internal HtmlTextLiteralSyntax(SyntaxKind kind, GreenNode textTokens)
        : base(kind)
    {
        SlotCount = 1;
        if (textTokens != null)
        {
            AdjustFlagsAndWidth(textTokens);
            _textTokens = textTokens;
        }
    }

    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(_textTokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _textTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.HtmlTextLiteralSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitHtmlTextLiteral(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitHtmlTextLiteral(this);
    }

    public HtmlTextLiteralSyntax Update(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != TextTokens)
        {
            var newNode = SyntaxFactory.HtmlTextLiteral(textTokens);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new HtmlTextLiteralSyntax(Kind, _textTokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new HtmlTextLiteralSyntax(Kind, _textTokens, GetDiagnostics(), annotations);
    }
  }

  internal abstract partial class CSharpSyntaxNode : RazorSyntaxNode
  {
    internal CSharpSyntaxNode(SyntaxKind kind, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CSharpSyntaxNode(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  internal sealed partial class CSharpTransitionSyntax : CSharpSyntaxNode
  {
    private readonly SyntaxToken _transition;

    internal CSharpTransitionSyntax(SyntaxKind kind, SyntaxToken transition, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 1;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
    }


    internal CSharpTransitionSyntax(SyntaxKind kind, SyntaxToken transition)
        : base(kind)
    {
        SlotCount = 1;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
    }

    public SyntaxToken Transition { get { return _transition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _transition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpTransitionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpTransition(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpTransition(this);
    }

    public CSharpTransitionSyntax Update(SyntaxToken transition)
    {
        if (transition != Transition)
        {
            var newNode = SyntaxFactory.CSharpTransition(transition);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpTransitionSyntax(Kind, _transition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpTransitionSyntax(Kind, _transition, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpMetaCodeSyntax : CSharpSyntaxNode
  {
    private readonly GreenNode _metaCode;

    internal CSharpMetaCodeSyntax(SyntaxKind kind, GreenNode metaCode, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 1;
        if (metaCode != null)
        {
            AdjustFlagsAndWidth(metaCode);
            _metaCode = metaCode;
        }
    }


    internal CSharpMetaCodeSyntax(SyntaxKind kind, GreenNode metaCode)
        : base(kind)
    {
        SlotCount = 1;
        if (metaCode != null)
        {
            AdjustFlagsAndWidth(metaCode);
            _metaCode = metaCode;
        }
    }

    public SyntaxList<SyntaxToken> MetaCode { get { return new SyntaxList<SyntaxToken>(_metaCode); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _metaCode;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpMetaCodeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpMetaCode(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpMetaCode(this);
    }

    public CSharpMetaCodeSyntax Update(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> metaCode)
    {
        if (metaCode != MetaCode)
        {
            var newNode = SyntaxFactory.CSharpMetaCode(metaCode);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpMetaCodeSyntax(Kind, _metaCode, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpMetaCodeSyntax(Kind, _metaCode, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpCodeLiteralSyntax : CSharpSyntaxNode
  {
    private readonly GreenNode _cSharpTokens;

    internal CSharpCodeLiteralSyntax(SyntaxKind kind, GreenNode cSharpTokens, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 1;
        if (cSharpTokens != null)
        {
            AdjustFlagsAndWidth(cSharpTokens);
            _cSharpTokens = cSharpTokens;
        }
    }


    internal CSharpCodeLiteralSyntax(SyntaxKind kind, GreenNode cSharpTokens)
        : base(kind)
    {
        SlotCount = 1;
        if (cSharpTokens != null)
        {
            AdjustFlagsAndWidth(cSharpTokens);
            _cSharpTokens = cSharpTokens;
        }
    }

    public SyntaxList<SyntaxToken> CSharpTokens { get { return new SyntaxList<SyntaxToken>(_cSharpTokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _cSharpTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpCodeLiteralSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpCodeLiteral(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpCodeLiteral(this);
    }

    public CSharpCodeLiteralSyntax Update(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> cSharpTokens)
    {
        if (cSharpTokens != CSharpTokens)
        {
            var newNode = SyntaxFactory.CSharpCodeLiteral(cSharpTokens);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpCodeLiteralSyntax(Kind, _cSharpTokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpCodeLiteralSyntax(Kind, _cSharpTokens, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpCodeBlockSyntax : CSharpSyntaxNode
  {
    private readonly GreenNode _children;

    internal CSharpCodeBlockSyntax(SyntaxKind kind, GreenNode children, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 1;
        if (children != null)
        {
            AdjustFlagsAndWidth(children);
            _children = children;
        }
    }


    internal CSharpCodeBlockSyntax(SyntaxKind kind, GreenNode children)
        : base(kind)
    {
        SlotCount = 1;
        if (children != null)
        {
            AdjustFlagsAndWidth(children);
            _children = children;
        }
    }

    public SyntaxList<RazorSyntaxNode> Children { get { return new SyntaxList<RazorSyntaxNode>(_children); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _children;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpCodeBlockSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpCodeBlock(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpCodeBlock(this);
    }

    public CSharpCodeBlockSyntax Update(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<RazorSyntaxNode> children)
    {
        if (children != Children)
        {
            var newNode = SyntaxFactory.CSharpCodeBlock(children);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpCodeBlockSyntax(Kind, _children, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpCodeBlockSyntax(Kind, _children, GetDiagnostics(), annotations);
    }
  }

  internal abstract partial class CSharpBlockSyntax : CSharpSyntaxNode
  {
    internal CSharpBlockSyntax(SyntaxKind kind, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CSharpBlockSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    public abstract CSharpTransitionSyntax Transition { get; }

    public abstract CSharpSyntaxNode Body { get; }
  }

  internal sealed partial class CSharpStatement : CSharpBlockSyntax
  {
    private readonly CSharpTransitionSyntax _transition;
    private readonly CSharpSyntaxNode _body;

    internal CSharpStatement(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }


    internal CSharpStatement(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body)
        : base(kind)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }

    public override CSharpTransitionSyntax Transition { get { return _transition; } }
    public override CSharpSyntaxNode Body { get { return _body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _transition;
            case 1: return _body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpStatement(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpStatement(this);
    }

    public CSharpStatement Update(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
        if (transition != Transition || body != Body)
        {
            var newNode = SyntaxFactory.CSharpStatement(transition, body);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpStatement(Kind, _transition, _body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpStatement(Kind, _transition, _body, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpStatementBodySyntax : CSharpSyntaxNode
  {
    private readonly CSharpMetaCodeSyntax _openBrace;
    private readonly CSharpCodeBlockSyntax _cSharpCode;
    private readonly CSharpMetaCodeSyntax _closeBrace;

    internal CSharpStatementBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax openBrace, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeBrace, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 3;
        AdjustFlagsAndWidth(openBrace);
        _openBrace = openBrace;
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
        AdjustFlagsAndWidth(closeBrace);
        _closeBrace = closeBrace;
    }


    internal CSharpStatementBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax openBrace, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeBrace)
        : base(kind)
    {
        SlotCount = 3;
        AdjustFlagsAndWidth(openBrace);
        _openBrace = openBrace;
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
        AdjustFlagsAndWidth(closeBrace);
        _closeBrace = closeBrace;
    }

    public CSharpMetaCodeSyntax OpenBrace { get { return _openBrace; } }
    public CSharpCodeBlockSyntax CSharpCode { get { return _cSharpCode; } }
    public CSharpMetaCodeSyntax CloseBrace { get { return _closeBrace; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _openBrace;
            case 1: return _cSharpCode;
            case 2: return _closeBrace;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpStatementBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpStatementBody(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpStatementBody(this);
    }

    public CSharpStatementBodySyntax Update(CSharpMetaCodeSyntax openBrace, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeBrace)
    {
        if (openBrace != OpenBrace || cSharpCode != CSharpCode || closeBrace != CloseBrace)
        {
            var newNode = SyntaxFactory.CSharpStatementBody(openBrace, cSharpCode, closeBrace);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpStatementBodySyntax(Kind, _openBrace, _cSharpCode, _closeBrace, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpStatementBodySyntax(Kind, _openBrace, _cSharpCode, _closeBrace, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpExpression : CSharpBlockSyntax
  {
    private readonly CSharpTransitionSyntax _transition;
    private readonly CSharpSyntaxNode _body;

    internal CSharpExpression(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }


    internal CSharpExpression(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body)
        : base(kind)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }

    public override CSharpTransitionSyntax Transition { get { return _transition; } }
    public override CSharpSyntaxNode Body { get { return _body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _transition;
            case 1: return _body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpExpression(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpExpression(this);
    }

    public CSharpExpression Update(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
        if (transition != Transition || body != Body)
        {
            var newNode = SyntaxFactory.CSharpExpression(transition, body);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpExpression(Kind, _transition, _body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpExpression(Kind, _transition, _body, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpExpressionBodySyntax : CSharpSyntaxNode
  {
    private readonly CSharpMetaCodeSyntax _openParen;
    private readonly CSharpCodeBlockSyntax _cSharpCode;
    private readonly CSharpMetaCodeSyntax _closeParen;

    internal CSharpExpressionBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax openParen, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeParen, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 3;
        if (openParen != null)
        {
            AdjustFlagsAndWidth(openParen);
            _openParen = openParen;
        }
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
        if (closeParen != null)
        {
            AdjustFlagsAndWidth(closeParen);
            _closeParen = closeParen;
        }
    }


    internal CSharpExpressionBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax openParen, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeParen)
        : base(kind)
    {
        SlotCount = 3;
        if (openParen != null)
        {
            AdjustFlagsAndWidth(openParen);
            _openParen = openParen;
        }
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
        if (closeParen != null)
        {
            AdjustFlagsAndWidth(closeParen);
            _closeParen = closeParen;
        }
    }

    public CSharpMetaCodeSyntax OpenParen { get { return _openParen; } }
    public CSharpCodeBlockSyntax CSharpCode { get { return _cSharpCode; } }
    public CSharpMetaCodeSyntax CloseParen { get { return _closeParen; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _openParen;
            case 1: return _cSharpCode;
            case 2: return _closeParen;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpExpressionBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpExpressionBody(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpExpressionBody(this);
    }

    public CSharpExpressionBodySyntax Update(CSharpMetaCodeSyntax openParen, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeParen)
    {
        if (openParen != OpenParen || cSharpCode != CSharpCode || closeParen != CloseParen)
        {
            var newNode = SyntaxFactory.CSharpExpressionBody(openParen, cSharpCode, closeParen);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpExpressionBodySyntax(Kind, _openParen, _cSharpCode, _closeParen, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpExpressionBodySyntax(Kind, _openParen, _cSharpCode, _closeParen, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpDirectiveSyntax : CSharpBlockSyntax
  {
    private readonly CSharpTransitionSyntax _transition;
    private readonly CSharpSyntaxNode _body;

    internal CSharpDirectiveSyntax(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }


    internal CSharpDirectiveSyntax(SyntaxKind kind, CSharpTransitionSyntax transition, CSharpSyntaxNode body)
        : base(kind)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(transition);
        _transition = transition;
        AdjustFlagsAndWidth(body);
        _body = body;
    }

    public override CSharpTransitionSyntax Transition { get { return _transition; } }
    public override CSharpSyntaxNode Body { get { return _body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _transition;
            case 1: return _body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpDirectiveSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpDirective(this);
    }

    public CSharpDirectiveSyntax Update(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
        if (transition != Transition || body != Body)
        {
            var newNode = SyntaxFactory.CSharpDirective(transition, body);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpDirectiveSyntax(Kind, _transition, _body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpDirectiveSyntax(Kind, _transition, _body, GetDiagnostics(), annotations);
    }
  }

  internal sealed partial class CSharpDirectiveBodySyntax : CSharpSyntaxNode
  {
    private readonly CSharpMetaCodeSyntax _keyword;
    private readonly CSharpCodeBlockSyntax _cSharpCode;

    internal CSharpDirectiveBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax keyword, CSharpCodeBlockSyntax cSharpCode, RazorDiagnostic[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(keyword);
        _keyword = keyword;
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
    }


    internal CSharpDirectiveBodySyntax(SyntaxKind kind, CSharpMetaCodeSyntax keyword, CSharpCodeBlockSyntax cSharpCode)
        : base(kind)
    {
        SlotCount = 2;
        AdjustFlagsAndWidth(keyword);
        _keyword = keyword;
        AdjustFlagsAndWidth(cSharpCode);
        _cSharpCode = cSharpCode;
    }

    public CSharpMetaCodeSyntax Keyword { get { return _keyword; } }
    public CSharpCodeBlockSyntax CSharpCode { get { return _cSharpCode; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return _keyword;
            case 1: return _cSharpCode;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Syntax.CSharpDirectiveBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCSharpDirectiveBody(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCSharpDirectiveBody(this);
    }

    public CSharpDirectiveBodySyntax Update(CSharpMetaCodeSyntax keyword, CSharpCodeBlockSyntax cSharpCode)
    {
        if (keyword != Keyword || cSharpCode != CSharpCode)
        {
            var newNode = SyntaxFactory.CSharpDirectiveBody(keyword, cSharpCode);
            var diags = GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(RazorDiagnostic[] diagnostics)
    {
         return new CSharpDirectiveBodySyntax(Kind, _keyword, _cSharpCode, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CSharpDirectiveBodySyntax(Kind, _keyword, _cSharpCode, GetDiagnostics(), annotations);
    }
  }

  internal partial class SyntaxVisitor<TResult>
  {
    public virtual TResult VisitRazorCommentBlock(RazorCommentBlockSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitHtmlTextLiteral(HtmlTextLiteralSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpTransition(CSharpTransitionSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpMetaCode(CSharpMetaCodeSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpCodeLiteral(CSharpCodeLiteralSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpCodeBlock(CSharpCodeBlockSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpStatement(CSharpStatement node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpStatementBody(CSharpStatementBodySyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpExpression(CSharpExpression node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpExpressionBody(CSharpExpressionBodySyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpDirective(CSharpDirectiveSyntax node)
    {
      return DefaultVisit(node);
    }

    public virtual TResult VisitCSharpDirectiveBody(CSharpDirectiveBodySyntax node)
    {
      return DefaultVisit(node);
    }
  }


  internal partial class SyntaxVisitor
  {
    public virtual void VisitRazorCommentBlock(RazorCommentBlockSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitHtmlTextLiteral(HtmlTextLiteralSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpTransition(CSharpTransitionSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpMetaCode(CSharpMetaCodeSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpCodeLiteral(CSharpCodeLiteralSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpCodeBlock(CSharpCodeBlockSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpStatement(CSharpStatement node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpStatementBody(CSharpStatementBodySyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpExpression(CSharpExpression node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpExpressionBody(CSharpExpressionBodySyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpDirective(CSharpDirectiveSyntax node)
    {
      DefaultVisit(node);
    }

    public virtual void VisitCSharpDirectiveBody(CSharpDirectiveBodySyntax node)
    {
      DefaultVisit(node);
    }
  }

  internal static partial class SyntaxFactory
  {
    public static RazorCommentBlockSyntax RazorCommentBlock(SyntaxToken startCommentTransition, SyntaxToken startCommentStar, SyntaxToken comment, SyntaxToken endCommentStar, SyntaxToken endCommentTransition)
    {
      if (startCommentTransition == null)
        throw new ArgumentNullException(nameof(startCommentTransition));
      switch (startCommentTransition.Kind)
      {
        case SyntaxKind.RazorCommentTransition:
          break;
        default:
          throw new ArgumentException("startCommentTransition");
      }
      if (startCommentStar == null)
        throw new ArgumentNullException(nameof(startCommentStar));
      switch (startCommentStar.Kind)
      {
        case SyntaxKind.RazorCommentStar:
          break;
        default:
          throw new ArgumentException("startCommentStar");
      }
      if (comment != null)
      {
      switch (comment.Kind)
      {
        case SyntaxKind.RazorComment:
        case SyntaxKind.Unknown:
          break;
        default:
          throw new ArgumentException("comment");
      }
      }
      if (endCommentStar == null)
        throw new ArgumentNullException(nameof(endCommentStar));
      switch (endCommentStar.Kind)
      {
        case SyntaxKind.RazorCommentStar:
          break;
        default:
          throw new ArgumentException("endCommentStar");
      }
      if (endCommentTransition == null)
        throw new ArgumentNullException(nameof(endCommentTransition));
      switch (endCommentTransition.Kind)
      {
        case SyntaxKind.RazorCommentTransition:
          break;
        default:
          throw new ArgumentException("endCommentTransition");
      }

      return new RazorCommentBlockSyntax(SyntaxKind.RazorComment, startCommentTransition, startCommentStar, comment, endCommentStar, endCommentTransition);
    }

    public static HtmlTextLiteralSyntax HtmlTextLiteral(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
      var result = new HtmlTextLiteralSyntax(SyntaxKind.HtmlTextLiteral, textTokens.Node);

      return result;
    }

    public static CSharpTransitionSyntax CSharpTransition(SyntaxToken transition)
    {
      if (transition == null)
        throw new ArgumentNullException(nameof(transition));
      switch (transition.Kind)
      {
        case SyntaxKind.Transition:
          break;
        default:
          throw new ArgumentException("transition");
      }

      var result = new CSharpTransitionSyntax(SyntaxKind.CSharpTransition, transition);

      return result;
    }

    public static CSharpMetaCodeSyntax CSharpMetaCode(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> metaCode)
    {
      var result = new CSharpMetaCodeSyntax(SyntaxKind.CSharpMetaCode, metaCode.Node);

      return result;
    }

    public static CSharpCodeLiteralSyntax CSharpCodeLiteral(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<SyntaxToken> cSharpTokens)
    {
      var result = new CSharpCodeLiteralSyntax(SyntaxKind.CSharpCodeLiteral, cSharpTokens.Node);

      return result;
    }

    public static CSharpCodeBlockSyntax CSharpCodeBlock(Microsoft.AspNetCore.Razor.Language.Syntax.InternalSyntax.SyntaxList<RazorSyntaxNode> children)
    {
      var result = new CSharpCodeBlockSyntax(SyntaxKind.CSharpCodeBlock, children.Node);

      return result;
    }

    public static CSharpStatement CSharpStatement(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
      if (transition == null)
        throw new ArgumentNullException(nameof(transition));
      if (body == null)
        throw new ArgumentNullException(nameof(body));

      var result = new CSharpStatement(SyntaxKind.CSharpStatement, transition, body);

      return result;
    }

    public static CSharpStatementBodySyntax CSharpStatementBody(CSharpMetaCodeSyntax openBrace, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeBrace)
    {
      if (openBrace == null)
        throw new ArgumentNullException(nameof(openBrace));
      if (cSharpCode == null)
        throw new ArgumentNullException(nameof(cSharpCode));
      if (closeBrace == null)
        throw new ArgumentNullException(nameof(closeBrace));

      var result = new CSharpStatementBodySyntax(SyntaxKind.CSharpStatementBody, openBrace, cSharpCode, closeBrace);

      return result;
    }

    public static CSharpExpression CSharpExpression(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
      if (transition == null)
        throw new ArgumentNullException(nameof(transition));
      if (body == null)
        throw new ArgumentNullException(nameof(body));

      var result = new CSharpExpression(SyntaxKind.CSharpExpression, transition, body);

      return result;
    }

    public static CSharpExpressionBodySyntax CSharpExpressionBody(CSharpMetaCodeSyntax openParen, CSharpCodeBlockSyntax cSharpCode, CSharpMetaCodeSyntax closeParen)
    {
      if (cSharpCode == null)
        throw new ArgumentNullException(nameof(cSharpCode));

      var result = new CSharpExpressionBodySyntax(SyntaxKind.CSharpExpressionBody, openParen, cSharpCode, closeParen);

      return result;
    }

    public static CSharpDirectiveSyntax CSharpDirective(CSharpTransitionSyntax transition, CSharpSyntaxNode body)
    {
      if (transition == null)
        throw new ArgumentNullException(nameof(transition));
      if (body == null)
        throw new ArgumentNullException(nameof(body));

      var result = new CSharpDirectiveSyntax(SyntaxKind.CSharpDirective, transition, body);

      return result;
    }

    public static CSharpDirectiveBodySyntax CSharpDirectiveBody(CSharpMetaCodeSyntax keyword, CSharpCodeBlockSyntax cSharpCode)
    {
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      if (cSharpCode == null)
        throw new ArgumentNullException(nameof(cSharpCode));

      var result = new CSharpDirectiveBodySyntax(SyntaxKind.CSharpDirectiveBody, keyword, cSharpCode);

      return result;
    }

    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type[] {
           typeof(RazorCommentBlockSyntax),
           typeof(HtmlTextLiteralSyntax),
           typeof(CSharpTransitionSyntax),
           typeof(CSharpMetaCodeSyntax),
           typeof(CSharpCodeLiteralSyntax),
           typeof(CSharpCodeBlockSyntax),
           typeof(CSharpStatement),
           typeof(CSharpStatementBodySyntax),
           typeof(CSharpExpression),
           typeof(CSharpExpressionBodySyntax),
           typeof(CSharpDirectiveSyntax),
           typeof(CSharpDirectiveBodySyntax)
        };
    }
  }
}
